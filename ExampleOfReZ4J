üöÄ Exemple Complet avec R√©silience4j et Spring Boot

On va configurer Circuit Breaker, Retry et Rate Limiter dans une application Spring Boot.


---

1Ô∏è‚É£ Ajout des d√©pendances

Ajoute ces d√©pendances dans ton pom.xml :

<dependencies>
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!-- Resilience4j -->
    <dependency>
        <groupId>io.github.resilience4j</groupId>
        <artifactId>resilience4j-spring-boot3</artifactId>
        <version>2.2.0</version>
    </dependency>

    <!-- Actuator pour observer le circuit breaker -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
    </dependency>
</dependencies>


---

2Ô∏è‚É£ Cr√©ation d'un Service avec Circuit Breaker et Retry

On va cr√©er un service qui appelle une API externe avec RestTemplate ou WebClient.

üìå Service avec Circuit Breaker et Retry

import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
import io.github.resilience4j.retry.annotation.Retry;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

@Service
public class ExternalApiService {
    private final RestTemplate restTemplate = new RestTemplate();
    private static final String SERVICE_NAME = "externalApi";

    @CircuitBreaker(name = SERVICE_NAME, fallbackMethod = "fallbackResponse")
    @Retry(name = SERVICE_NAME)
    public String callExternalService() {
        System.out.println("üîÑ Tentative d'appel √† l'API externe...");
        return restTemplate.getForObject("http://fake-api.com/data", String.class);
    }

    // M√©thode fallback si l'API √©choue
    public String fallbackResponse(Exception e) {
        return "‚ö†Ô∏è Service indisponible. Veuillez r√©essayer plus tard.";
    }
}

‚úÖ Si l'API externe √©choue, Resilience4j va :

1. R√©essayer l‚Äôappel (Retry)


2. Couper le circuit apr√®s plusieurs √©checs (Circuit Breaker)


3. Retourner la r√©ponse de secours fallbackResponse




---

3Ô∏è‚É£ Ajout d‚Äôun Contr√¥leur

On expose l‚Äôappel au service via une API REST :

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/api")
public class ExternalApiController {
    private final ExternalApiService externalApiService;

    public ExternalApiController(ExternalApiService externalApiService) {
        this.externalApiService = externalApiService;
    }

    @GetMapping("/call")
    public String callExternalApi() {
        return externalApiService.callExternalService();
    }
}

‚úÖ Appelle cette API avec :

curl http://localhost:8080/api/call


---

4Ô∏è‚É£ Configuration de Resilience4j dans application.yml

Ajoute cette configuration pour d√©finir :

Le nombre de tentatives pour Retry

Le nombre d‚Äô√©checs avant d‚Äôouvrir le circuit (CircuitBreaker)

La limitation du nombre d‚Äôappels (RateLimiter)


resilience4j:
  circuitbreaker:
    instances:
      externalApi:
        failureRateThreshold: 50 # Ouvre le circuit si 50% des appels √©chouent
        waitDurationInOpenState: 5000ms # Attente avant de retester
        permittedNumberOfCallsInHalfOpenState: 2 # Nombre d'essais en semi-ouvert
        slidingWindowSize: 10 # Nombre de requ√™tes prises en compte pour le calcul du taux d'erreur

  retry:
    instances:
      externalApi:
        maxAttempts: 3 # Nombre max de tentatives avant √©chec
        waitDuration: 2000ms # Attente entre chaque tentative

  ratelimiter:
    instances:
      externalApi:
        limitForPeriod: 2 # Max 2 appels par p√©riode
        limitRefreshPeriod: 10s # P√©riode de rafra√Æchissement
        timeoutDuration: 0 # Pas d‚Äôattente si limite atteinte


---

5Ô∏è‚É£ Test du Circuit Breaker et Retry

üîπ √âtape 1 : Appeler l‚ÄôAPI avec succ√®s
Si http://fake-api.com/data r√©pond, tu verras "R√©ponse de l'API".

üîπ √âtape 2 : Simuler un √©chec
Si l'API √©choue (500 ou Timeout), Resilience4j va :
‚úÖ R√©essayer 3 fois (gr√¢ce √† Retry)
‚úÖ Ouvrir le circuit si 50% des appels √©chouent
‚úÖ Appeler la m√©thode fallbackResponse


---

6Ô∏è‚É£ Observer l‚Äô√©tat du Circuit Breaker

Ajoute Spring Actuator dans application.yml :

management:
  endpoints:
    web:
      exposure:
        include: health,metrics

Puis, consulte l'√©tat du Circuit Breaker :

curl http://localhost:8080/actuator/health

‚úÖ Si tout fonctionne, l‚Äô√©tat sera :

{"status":"UP"}

‚úÖ Si le circuit est ouvert, tu verras :

{
  "status": "DOWN",
  "components": {
    "circuitBreakers": {
      "externalApi": {
        "state": "OPEN"
      }
    }
  }
}


---

üìå Conclusion

Avec ce setup, ton application est plus r√©sistante aux pannes : ‚úÖ Retry : R√©essaye automatiquement en cas d‚Äô√©chec
‚úÖ Circuit Breaker : Coupe le service apr√®s trop d‚Äô√©checs
‚úÖ Rate Limiter : Emp√™che une surcharge des appels

üí° Tu veux ajouter d'autres modules comme Bulkhead ou TimeLimiter ?

